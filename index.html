<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>
    nanhan27's Blog
    
</title>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<link rel="stylesheet" href="/style/style.css">
<script src="/script/jquery.min.js"></script>
<script>
    var CONFIG = {
        title: "nanhan27's Blog",
        author: "nanhan",
        lightbox: true,
        animate: true
    }
</script>



    <link rel="stylesheet" href="/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">









    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<!--Mathjax-->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    }); 
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';                 
        }       
    });
    </script>
    <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
</head>
<body>
    <div class="progress">
    <div class="progress-inner"></div>
</div>
    <div class="body">
    <div class="tagcloud" id="tagcloud">
    <div class="tagcloud-inner">
        
    </div>
</div>
    <header class="header" id="header">
    <div class="title syuanpi tvIn">
    <div class="table">
        <div class="connect">
            <div class="connect-inner">
                <span><a href="/">nanhan27's Blog</a></span>
                
            </div>
        </div>
    </div>
</div>
    <nav class="main-nav syuanpi tvIn">
<div class="table">

    <ul class="menu">
        
        
            <li class="menu-item">
                <a href="/">
                    <span>文章</span>
                    
                        <span class="menu-item-label">article</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/archives">
                    <span>目录</span>
                    
                        <span class="menu-item-label">archives</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="javascript:;" id="tags">
                    <span>标签</span>
                    
                        <span class="menu-item-label">tags</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/aboutme">
                    <span>关于</span>
                    
                        <span class="menu-item-label">about</span>
                    
                </a>
            </li>
        
        
    </ul>

</div>
</nav>
<div class="mobile-nav"></div>
</header>
    <div class="container">
        <main class="main" id="main">
            
    

<section class="posts">
    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月19日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/19/20170819离线赛/">20170814离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、LOVE"><a href="#A、LOVE" class="headerlink" title="A、LOVE"></a>A、LOVE</h2><p>关键字：前缀和、高精</p>
<p>Task</p>
<p>在一个字符串中，按照顺序选出四个字母，组成LOVE，有多少种方案。</p>
<p>【分析】</p>
<p>这道题比较正常，写法还是比较多样的。</p>
<p>那么用前缀的想法，可以算出当前的O以及之前的O组成LO的方案，当前的V以及之前组成$LOV​$的方案，对于一个E，就能计算出LOVE的方案了。</p>
<p>但是我在比赛的时候知道100%的数据会爆long long，为了省麻烦，就将long long换成了double！完全没有考虑double的有效位数只有16位。</p>
<p>【反思】</p>
<p>考试就是那更多的分数，不要怕麻烦。</p>
<p>【总结】</p>
<p>double的有效精度只有16位！</p>
<p>double的有效精度只有16位！</p>
<p>double的有效精度只有16位！</p>
<h2 id="B、毕加猪"><a href="#B、毕加猪" class="headerlink" title="B、毕加猪"></a>B、毕加猪</h2><p>关键字：图论，有负权的最短路</p>
<p>Task</p>
<p>在有向图中，是否存在一条路径，使得从起点到终点的权值和小于等于T。</p>
<p>【分析】</p>
<p>比较容易想到需要找到负环。只要起点能到达某个负环，并且这个负环能到达终点，那么就能按时到达。但是当时脑子一片空白，完全不会。</p>
<p>之前当然是知道有些最短路的算法能够处理边权有负的情况，但是真的很少用$Bellmen\ Ford$、$SPFA$去处理，甚至连用$Floyd$判断是否存在负环都很模糊。</p>
<p>比赛的时候就稀里糊涂地用$tarjan$先缩了个点，然后在每个强连通中判断每个强连通中有没有负环。如果没有负环就直接$Floyd$，如果有的话，再重新建边，将连向负环的边权设为负无穷，然后$Floyd$。</p>
<p>然而正解只需要用$Floyd$找出某一个点是否在负环上，且这个点与起点和终点是联通的就行了。</p>
<p>【反思】</p>
<p>1、对经典的算法不重视，以为只要掌握$Dijkstra$和$Floyd$就够用了。</p>
<p>2、只需要判断是否存在某个负环，与起点和终点相连通，而我却在知道有没有负环后重新建图，对我所求得目标不明确，思路不清晰。</p>
<p>【总结】</p>
<p>$Floyd$判断是否存在负环只需要判断$dis[i][i]$是否小于0。</p>
<p>$SPFA$判断是否存在负环只需要一个点进入队列的次数是否大于$n-1$。</p>
<p>$Bellmen\ Ford$与$SPFA$类似，判断在在更新$n-1$次后判断每条边是否还能让路径两端的点的距离继续减小。</p>
<p>【代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">" = "</span>&lt;&lt;x&lt;&lt;endl;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 1e18</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3005</span></div><div class="line"><span class="keyword">int</span> n,m,ti,cas;</div><div class="line">ll d[M][M];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cas);</div><div class="line">    <span class="keyword">while</span>(cas--)&#123;</div><div class="line">        <span class="keyword">int</span> p,q;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;ti);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)d[i][k]=oo;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,c;i&lt;=m;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;c);</div><div class="line">            d[u][v]=min(d[u][v],<span class="number">1l</span>l*c);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;p,&amp;q);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</div><div class="line">                    d[j][k]=min(d[j][k],d[j][i]+d[i][k]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(d[p][q]+ti&lt;=<span class="number">0</span>||d[q][p]+ti&lt;=<span class="number">0</span>)<span class="built_in">puts</span>(<span class="string">"yes"</span>);</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">bool</span> ok=<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;ok;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(d[i][i]&lt;<span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(d[p][i]!=oo&amp;&amp;d[i][q]!=oo||d[q][i]!=oo&amp;&amp;d[i][p]!=oo)ok=<span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(ok)<span class="built_in">puts</span>(<span class="string">"no"</span>);</div><div class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"yes"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C、k倍数字——-UOJ140"><a href="#C、k倍数字——-UOJ140" class="headerlink" title="C、k倍数字——$UOJ140$"></a>C、k倍数字——$UOJ140$</h2><p>关键字：数位$dp$</p>
<p>Task</p>
<p>给定两个数字R和k，求满足下列条件的x个数。</p>
<p>1、满足1≤x≤R</p>
<p>2、定义函数f(x) 为 x 的各位数字之和，例如f(13)=4,f(233)=8。满足 f(x)=f(k·x)</p>
<p>【分析】</p>
<p>数位$dp$应该很好想到，关键是哪些状态需要存在下标上才能进行转移。</p>
<p>通常的数位$dp$应该是从高位往低位的，但是因为这道题目如果从高位往低，那么转移就比较麻烦，所以选择从低往高。对于每一位，我们要添加一个数字，那么此时的各位数字之和是能够转移过来的。但是这些信息并不能直接算出$k·x$的各位数字之和。</p>
<p>我在网上大概搜了一下，$dp$下标存的大概有这些东西：数位和、数位和模后的结果、是否进位、进位所少、前一位是多少、是否已经满足了约束条件、有无前导零和是否严格小于上限等等。经验要慢慢积累，但是知道这些起码有一些方向可以去尝试。</p>
<p>至于这道题，我们记录当前这个数的数位和、这个数$<em>K$后的数位和，这个数$</em>K$后的数位和所产生的进位是多少。</p>
<p>那么就可以转移了：</p>
<p>$dp[i+1][sum+ch][sum1+(ch<em>K+r)10][(ch</em>K+r)/10]=dp[i][sum][sum1][r]$</p>
<p>由于还要考虑当前数字是否严格小于上限R，所以还需要一维p记录状态。</p>
<p>但是这样空间会炸，所以我们不能将两个sum同时记录下来了，我们将两个sum的差d记录在$dp$上。</p>
<p>【反思】</p>
<p>暴力炸了就真的没有救了。</p>
<p>【总结】</p>
<p>数位$dp$的下标存的状态与前面已经枚举的数位有关并且通常是根据约束条件当前枚举的这一位能使得状态<strong>完整</strong>(比如一个状态涉及到连续k位，那么就保存前k-1的状态，当前枚举的第k个是个恰好凑成成一个完整的状态，不过像状态是数位的和就直接保存前缀和为状态了)</p>
<p>【代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">ll dp[<span class="number">25</span>][<span class="number">410</span>][<span class="number">1010</span>][<span class="number">2</span>];</div><div class="line"><span class="keyword">char</span> s[<span class="number">25</span>];</div><div class="line"><span class="keyword">int</span> K,n;</div><div class="line">ll R;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %d"</span>,&amp;R,&amp;K);</div><div class="line">    <span class="keyword">while</span>(R)s[++n]=R%<span class="number">10</span>,R/=<span class="number">10</span>;</div><div class="line">    dp[<span class="number">0</span>][<span class="number">200</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">2</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;=<span class="number">400</span>;d++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">0</span>;now&lt;<span class="number">2</span>;now++)&#123;</div><div class="line">                    <span class="keyword">if</span>(!dp[i][d][j][now])<span class="keyword">continue</span>;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> ch=<span class="number">0</span>;ch&lt;<span class="number">10</span>;ch++)&#123;</div><div class="line">                        <span class="keyword">int</span> nxt;</div><div class="line">                        <span class="keyword">if</span>(s[i+<span class="number">1</span>]&gt;ch)nxt=<span class="number">0</span>;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]&lt;ch)nxt=<span class="number">1</span>;</div><div class="line">                        <span class="keyword">else</span> nxt=now;</div><div class="line">                        <span class="keyword">int</span> nj=(K*ch+j)/<span class="number">10</span>;</div><div class="line">                        <span class="keyword">int</span> nd=d+ch-(K*ch+j)%<span class="number">10</span>;</div><div class="line">                        dp[i+<span class="number">1</span>][nd][nj][nxt]+=dp[i][d][j][now];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[n+<span class="number">3</span>][<span class="number">200</span>][<span class="number">0</span>][<span class="number">0</span>]<span class="number">-1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月18日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/18/数位dp模板/">数位$dp$模板</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <p>由于百度之星复赛那道数位$dp​$的爆炸，我发现我写数位$dp​$的记搜版本并没有什么套路，重新写一道题就要重新去考虑哪些细节该怎样设计，这样会花费我大量的时间，所以我在这里放一份较为通用的模板，供自己参考。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/18/数位dp模板/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月17日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/17/2017 Multi-University Training Contest 7/">2017 Multi-University Training Contest 7</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="1006、Free-from-square"><a href="#1006、Free-from-square" class="headerlink" title="1006、Free from square"></a>1006、Free from square</h2><p>关键字：状压$dp$、分组背包</p>
<p>【分析】</p>
<p>题目的模型稍微转化一下，就是说选一些互质的数。因为一个数不会含有两个大于$\sqrt {n}$的质因数，所以我们开始思考小于$\sqrt {n}$的质因数。这样的质因数只有8个，所以想到状压，将取的集合存在下标。</p>
<p>但是大于$\sqrt {n}$的质因数该怎么处理？由于大于$\sqrt {n}$的质因数的个数很多，不可能把它存在下标上，所以我们需要一种$dp$转移的顺序，使得最后计算的答案既不重复也不遗漏。比赛的时候就是卡在了这里！我只是想到43、86之类的不能放在一起，$YY$了一下莫比乌斯系数，发现太过复杂，也就没有继续往下想了。</p>
<p>实际上，这就是分组背包嘛！那么这道题也就没有了。</p>
<p>$dp[cur][j][s]$表示当前组cur，取j个数，小于$\sqrt {n}$的质因数的集合为s。</p>
<p>而且还有一个小优化：实际上对于n=500，最多能取到的数也只有95个。所以$dp$的空间能节省很多，速度也就变快了。</p>
<p>【算法流程】</p>
<p>1、将含有大于$\sqrt {n}$的质因数的数先处理。</p>
<p>2、处理只含小于$\sqrt {n}$的质因数并且本身不含有平方因子的数。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/17/2017 Multi-University Training Contest 7/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月16日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/16/20170814离线赛/">20170814离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、完全图计数"><a href="#A、完全图计数" class="headerlink" title="A、完全图计数"></a>A、完全图计数</h2><p>关键字：折半枚举，高维前缀和</p>
<p>【分析】</p>
<p>比赛的时候爆0真的是没想到。</p>
<p>一开始当然想到了$O(n<em>2^n)$的暴力，这样就能拿到70分了。但是我却写了一个奇怪的写法，希望能水到更多分。样例也跑出来了。谁知道在$dfs$里面会忘了$return$。就爆0了。这还不止，我加了$return$后交到网站去，结果只有60分。连$O(n</em>2^n)$的暴力都不如……看来比赛的时候还是应该稳，把该拿到的分全部拿到再说别的。</p>
<p>正解是折半枚举。折半枚举的特征大概就是在$O(2^n)$不能解决的时候$O(2^{n/2})$却能解决。想法是枚举一半，计算另一半。</p>
<p>我们将$[0,n/2-1]$取或不取的集合的情况处理出来，然后用高维前缀和处理出任意集合包含其子集的可行的方案数。大概是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hf;i++)&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=(<span class="number">1</span>&lt;&lt;hf)<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</div><div class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1l</span>l&lt;&lt;i))cnt[j]+=cnt[j^(<span class="number">1</span>&lt;&lt;i)];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么对于$[n/2,n-1]$$dfs$枚举集合时，直接用已处理出的$[0,n/2-1]$的方案计算即可。</p>
<p>【总结】</p>
<p>1、多分析数据。</p>
<p>2、暴力别敲错！</p>
<h2 id="B、书架面积——NWERC-2006"><a href="#B、书架面积——NWERC-2006" class="headerlink" title="B、书架面积——NWERC 2006"></a>B、书架面积——NWERC 2006</h2><p>关键字：$dp$</p>
<p>【分析】</p>
<p>这道题花了我将近三个小时。这其实是一个重大的失误。</p>
<p>前一个小时敲一个我认为能拿70分（$O(150^3*n)$）的贪心，所以没有敲其他的切分代码（实在不应该）。先按宽度排序，枚举三行的最高长度，然后贪心先放此时宽度最大的，并且时刻维护三行的最高长度不变。</p>
<p>但是大数据过不了，大了十几。接下来半个小时开始调试，没有看出代码的问题。可能是算法的问题！由于需要满足放在某一行的书的高度不能超过枚举的高度，会导致贪心出错！</p>
<p>鉴于仅剩一个半小时，第三题还没有写，我去看第三题，并花了20分钟将暴力敲完，综合当时的情况，我便没有去敲“没有2操作”的切分，继续回到了第二题来。</p>
<p>我舍弃一开始枚举三行的最高长度的贪心思路，转向用宽度$dp$。若将宽度存入下标，只需要将两行的宽度，最后一行是可以直接算出来的。$dp[a][i][j]$的定义为取到第a个，第一行的宽度为i，第二行的宽度为j的最小的最大高度和。开始$dp$转移之前先将书按照高度排序，这样就能保证取第a个在第一行（或第二行）的时候不会让原有的最高高度发生改变，使$dp$的转移的信息一定是正确的。</p>
<p>当然这时$dp$数组是开不下的。我们从$dp$转移入手：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(dp[i<span class="number">-1</span>][j][k]==<span class="number">-1</span>)<span class="keyword">continue</span>;</div><div class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)chk(dp[i][j][k+a[i].t],dp[i<span class="number">-1</span>][j][k]+a[i].h);</div><div class="line"><span class="keyword">else</span> chk(dp[i][j][k+a[i].t],dp[i<span class="number">-1</span>][j][k]);</div><div class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)chk(dp[i][j+a[i].t][k],dp[i<span class="number">-1</span>][j][k]+a[i].h);</div><div class="line"><span class="keyword">else</span> chk(dp[i][j+a[i].t][k],dp[i<span class="number">-1</span>][j][k]);</div><div class="line"><span class="keyword">if</span>(sum-j-k==<span class="number">0</span>)dp[i][j][k]+=a[i].h;</div></pre></td></tr></table></figure>
<p>我们发现当前第i个的信息完全是由i-1那里继承过来的。（因为书一定要放在书架上），所以直接将第一维省去就好了。</p>
<p>【总结】</p>
<p>1、不管有没有想到正解，暴力和切分一定要敲。</p>
<h2 id="C、奇怪的树"><a href="#C、奇怪的树" class="headerlink" title="C、奇怪的树"></a>C、奇怪的树</h2><p>关键字：树状数组、树链剖分</p>
<p>【分析】</p>
<p>1~2：暴力20分</p>
<p>5、7 、8：30分</p>
<p>我们先考虑一下1、2操作本质会产生什么影响。</p>
<p>1操作的实质就是如果这个点的$dep$是奇数，那么$dep$为偶数的点的颜色会改变。同理$dep$是偶数，那么$dep$为奇数的点的颜色会改变。</p>
<p>如果没有操作2的话，那么这一棵树其实只有四种情况：</p>
<p>1、都不改</p>
<p>2、奇数点不改，偶数点改</p>
<p>3、奇数点改，偶数点不改</p>
<p>4、都改</p>
<p>那么对于没有2操作时，我们能够用四次$dfs$预处理出所有的答案。这里有。</p>
<p>3：10分</p>
<p>在链上，我们考虑一个点i的答案是怎么组成的。应该是这个点左边黑点的$dfn$之和、右边黑点的个数乘i相加得到。那我们还是维护四种情况的这两个信息就好了。因为这是单点更新（2操作），区间查询，所以我们可以用线段树或树状数组来维护。</p>
<p>至于正解，用树链剖分将树转化成若干链，然后更新和询问都是跳重链。思路和链的想法差不多，只不过在计算答案的时候注意将重复计算的部分减掉！</p>
<p>【总结】</p>
<p>1、从小分的写法深入</p>
<p>2、自己不太好写，别人也不一定能写，不要钻牛角尖</p>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月13日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/13/2017 Multi-University Training Contest 6/">2017 Multi-University Training Contest 6</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="1001、String"><a href="#1001、String" class="headerlink" title="1001、String"></a>1001、String</h2><p>关键字：字符串、$Trie$树、$CDQ$分治</p>
<p>【分析】</p>
<p>首先我们可以知道，如果将单词按字典序排序，那么对于一个前缀，单词所在的下标一定是一段连续的区间。将单词旋转后排序，查询后缀也是一样的。</p>
<p>那么题目就转化成对于一个询问，其正序下标在$[x1,x2]$，逆序下标在$[y1,y2]$的单词有多少个。</p>
<p>如果知道了一个询问的$x1、x2、y1、y2$，那么题目就等价于求平面上一个矩形中的点的个数，这个可以用扫描线+线段树完成。</p>
<p>预处理出$x1、x2、y1、y2$可以用$Trie$树来完成，即每个节点存下某个前缀的字典序下标的最大和最小值。然后用询问的前缀和后缀去跑这棵$Trie$树。</p>
<p>但是题目中还有一个限制条件：$前缀和后缀不能重叠。$</p>
<p>这个条件正解中是用$Hash$将不满足的情况减去，但是$小C$说这样太麻烦了。这样就说明一个单词，如果其长度小于询问的前缀+后缀长度，那么它是不能被计算的，所以我们人为地添加了操作顺序这一维度，即边加点边询问。而这个问题正是$CDQ$的入门题目$Mokia$。</p>
<p>【算法流程】</p>
<p>1、顺序字符串排序，建$Trie$树，更新节点的信息。询问的前缀查询区间$[x1,x2]$。</p>
<p>2、逆序字符串做相同操作。</p>
<p>3、将插入和询问操作按长度从大到小排序，进行$CDQ$分治，BIT维护。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/13/2017 Multi-University Training Contest 6/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月12日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/12/20170811离线赛/">20170811离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、小宝卖猪"><a href="#A、小宝卖猪" class="headerlink" title="A、小宝卖猪"></a>A、小宝卖猪</h2><p>关键字：数学</p>
<p>【分析】</p>
<p>题目要求的是$Max(\sum W[i]<em>(P[j]-t</em>D[j]))$。那么根据排序不等式我们知道顺序相乘&gt;乱序相乘&gt;逆序相乘。所以$W[i]$、$(P[j]-t*D[j])$各自从小到大排序相乘就好了。</p>
<p>但是，由于自己可能耳背，听错了xxx的提醒，放心的将long long删去，就 爆 炸 了。</p>
<p>【总结】</p>
<p>1、多注意数据的范围，两个数相乘的时候条件反射思考是否会炸。</p>
<h2 id="B、放书"><a href="#B、放书" class="headerlink" title="B、放书"></a>B、放书</h2><p>关键字：$dp$</p>
<p>【分析】</p>
<p>首先我想了好久，但是就是没有什么切入点，想过好几种$dp$状态都不容易转移。于是就去写C题的50分了。</p>
<p>有一个点想通了，后面就简单了：如果我们要抽出某一本书，我们到底要放在哪里？我想了很久，已有的区间的首尾？中间？放在哪里？最后发现，根本不需要知道！因为一本书如果被取出，那么它最后一定会放在相同高度的书附近，对答案没有贡献。</p>
<p>综合所有状态，我们定义$dp[i][pre][k][s]$表示对于第i本书，上一本没有被取走的书是$pre$，已经用了$k$，区间中已有$s$集合的书。</p>
<p>记搜显然很简单。但这样就不能优化空间了，只有90分。所以我们选择循环转移，这样就可以过了。</p>
<p>转移如下：</p>
<p>$chk(dp[cur][pre][k+1][s],dp[!cur][pre][k][s])$<br>$chk(dp[cur][h[i]][k][s|(1&lt;&lt;h[i])],dp[!cur][pre][k][s]+(h[i]!=pre))$</p>
<p>至于比赛的时候为什么没有想到，是因为我一直在想上面的那个问题，时间都浪费在如何转移之前那个不正确的dp状态。导致最后连写记搜的时间都很少，也就没有去想空间优化了。</p>
<p>【总结】</p>
<p>1、多问自己几个为什么。</p>
<p>2、多思考状态对答案的影响、已知量与未知量的关系。</p>
<h2 id="C、Crash的旅行计划"><a href="#C、Crash的旅行计划" class="headerlink" title="C、Crash的旅行计划"></a>C、Crash的旅行计划</h2><p>关键字：图论、树链剖分、线段树</p>
<p>【分析】</p>
<p>小分写起来思路还是比较清晰的。</p>
<p>1~2：暴力修改，查询u时以u为根，然后树形$dp$遍历整棵树</p>
<p>3~5：用线段树维护每个点的最大的“前缀”和“后缀”。</p>
<p>6~7：仍是树形$dp$的想法，但是由于这是一棵完全二叉树，所以就算每次暴力修改一个点的所有父亲，复杂度还是$O(\log n)$的。询问也是同理，直接遍历它的所有父亲，考虑答案的组成方式更新答案。</p>
<p>8：由于树的深度并不会超过40，也可以暴力跳父亲，但是需要用$multiset$来维护一个节点的最大权值。</p>
<p>正解是树链剖分+线段树。不过自己的树链剖分并不是很熟练，所以还需要多练习。</p>
<p>【总结】</p>
<p>1、树的问题，先从链想起。</p>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月11日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/11/网络流模板/">网络流模板</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <p>虽然说网络流的题目最重要的是建边，但是这里还是放一份模板比较好，免得以后忘了有麻烦。<br>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/11/网络流模板/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月10日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/10/20170809离线赛/">20170809离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、01完美矩阵"><a href="#A、01完美矩阵" class="headerlink" title="A、01完美矩阵"></a>A、01完美矩阵</h2><p>关键字：前缀和</p>
<p>【分析】</p>
<p>首先$O(n^4)$的暴力应该不难想。写的好的人就过了，写不好就自认倒霉。</p>
<p>首先还是枚举，不过我们先枚举两行作为边框的行，对于列我们$O(m)$扫过来。这样的思路还是十分常见的。</p>
<p>对于一列有两种情况。</p>
<p>如果是全1，那么它就能作为矩形的右边框，那我们就需要知道之前有多少列能够作为左边框。我们将元素看成1和-1来处理前缀和，那么对于当前列的前缀和sum，我们需要知道之前有多少前缀为sum-1、sum、sum+1的情况。</p>
<p>如果不是，那么之前记录的前缀信息就没有意义了，所以需要清除掉。</p>
<p>【总结】</p>
<p>1、枚举，思考能否枚举+贪心。</p>
<h2 id="B、维修道路——codeforces"><a href="#B、维修道路——codeforces" class="headerlink" title="B、维修道路——codeforces"></a>B、维修道路——codeforces</h2><p>关键字：图论、树的直径</p>
<p>【分析】</p>
<p>比赛时我先想到枚举一个点作为不相交的那个点，然后用树形$dp$求出子树内最长的链和子树外最长的链，再更新答案。那么只需要正反各来一遍$dfs$就能完成。复杂度就是$O(n^2)$。</p>
<p>因为想到树的直径的求法好像也是正反一遍$dfs$，于是就想到先将树的直径抽出，然后在这个直径上操作。</p>
<p>最后只需要用前缀的思想求出以某个点作为不相交的点，左边最长的链和右边最长的链就好了。总的复杂度是$O(n)$。</p>
<p>【总结】</p>
<p>1、从暴力入手，高于暴力。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/10/20170809离线赛/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月9日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/09/20170807离线赛/">20170807离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、务农政策——Codechef-JAN17"><a href="#A、务农政策——Codechef-JAN17" class="headerlink" title="A、务农政策——Codechef JAN17"></a>A、务农政策——Codechef JAN17</h2><p>关键字：单调队列</p>
<p>【分析】</p>
<p>题目的模型比较简单，转化成二维找最大值的问题。</p>
<p>个人认为这道题与上次考过的<strong>插队</strong>很像。那道题是一维的，而这个是二维的，如何降维呢？我们先考虑将每一行的形如$[j,j+b-1]$的最大值用单调队列预处理出来。这个只需要先循环行再循环列就能做到。这样我们就将一个区间变成了一个点。</p>
<p>接下来再先枚举列，再枚举行，每次操作只需要将不满足当前行数的元素删除，再将当前行、当前列的最大值塞入单调队列并更新答案就好了。</p>
<p>所以最后的复杂度就是$O(Tnm)$。</p>
<h2 id="B、刷副本——Codechef-JUNE16"><a href="#B、刷副本——Codechef-JUNE16" class="headerlink" title="B、刷副本——Codechef JUNE16"></a>B、刷副本——Codechef JUNE16</h2><p>关键字：数学</p>
<p>【分析】</p>
<p>题目的关键就是怎么求乘积的首位！因为只要知道这个，暴力都能拿85分！（<del>虽然是因为数据水</del>）</p>
<p>我们设最后的乘积是$w$，那么一定能表示成$w=a*10^b$，$a$是一个属于$[1,10)$的实数。那么$w$的首位就是$a$的整数部分。</p>
<p>这里就有一个比较常见（che dan）的思路了。将乘积用底数函数转化成加和。</p>
<p>那么$\lg w=\lg a*10^b=b+\lg a$，对于一个$w$，$w=\prod f[i]$，根据数学知识，我们知道$\lg w=\lg f[x]+\lg f[y]+……$</p>
<p>综合上面两个式子，我们发现$b+\lg a=\lg f[x]+\lg f[y]+……$。而b是整数，a是实数。我们先求出$sumlg$，那么$\lg a=sumlg-(int)sumlg$，用系统的pow函数就可以直接搞出a，那么答案就是a的整数部分。不过这里还需要考虑计算时的精度问题。</p>
<p>有了上面的数学推理，我们还需要思考题目中的另一个青蛙跳的模型。</p>
<p>我们考虑修改一个点$i$的值会影响到那些R的答案。应该比较容易想到，会影响到$R=（i-1的因子）$的答案。这样预处理就比较简单了。但需要特殊考虑$i=1$时的情况，因为$i-1=0$且修改1会对所有$R$造成影响，所以我们预处理的$sumlg[r]$中不包括i=1的$\lg F[1]$，只要在最后算答案的时候再加上去就好了。</p>
<p>至于那个乘积模$1e9+7$，道理是一样的。</p>
<p>还有一个注意点，因为有模，所以记录乘积的那个数组不能先将原数除了后再乘上新的数，需要乘上逆元才行。</p>
<p>比赛的时候没有写高精，因为总觉得强一点的数据会直接卡高精，这样一卡，其实也就没有比暴力多多少分了，所以就没有动力去敲高精了。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/09/20170807离线赛/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月6日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/06/20170805离线赛/">20170805离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、文件解压"><a href="#A、文件解压" class="headerlink" title="A、文件解压"></a>A、文件解压</h2><p>关键字：括号匹配</p>
<p>【分析】</p>
<p>这道题作为第一题还是比较良心的。既比较好想到，代码又不是很长，可以让人进入状态。</p>
<p>首先是括号匹配，先预处理出每个左括号对应的右括号，然后直接从一个完整的字符串dfs下去。</p>
<h2 id="B、球染色——SGU183"><a href="#B、球染色——SGU183" class="headerlink" title="B、球染色——SGU183"></a>B、球染色——SGU183</h2><p>关键字：dp优化</p>
<p>【分析】</p>
<p>首先因为至少需要两个黑球，所以我们可以定义：$dp[i][j]$表示将i和j的位置染成黑色的最小花费。（i在前，j在后）</p>
<p>对于一个i，我们枚举一个j，所以j的范围是$[i+1,i+m-1]$，那么$dp[i][j]$应该从哪里转移过来呢？</p>
<p>首先既然要在j的位置染色，就说明j-1在j没有染色时时满足连续m个至少有两个黑球的，所以既然要建j，就应该从$[j-1-m+1,i)$那里转移过来。</p>
<p>所以：$dp[i][j]=min(dp[k][i])+c<a href="k\in[j-m,i-1]">j</a>$。我们先来看看如何将上述dp从$O(n*m^2)$优化到$O(nm)$。</p>
<p>我们注意到如果正着枚举j的话，可转移的$dp[k][i]$会越来越少。也就是说每当j+1，对min有所贡献的$dp[k][i]$会减少一个，这样我们就需要重新用$O(m)$的复杂度维护min的信息。</p>
<p>所以我们选择倒着枚举j，这样一定是对的，而且边转移边维护min的信息，将复杂度优化到$O(nm)$了。</p>
<p>因为题目的空间只能开3200万的数组，所以纵使这样优秀的$O(nm)$的时间复杂度也只有80分。</p>
<p>我们注意到，每次只会从当前的i的前m个元素中转移，所以dp数组的第一维对于当前转移有很大的部分是无效的，之后更是没有用。所以我们将dp数组滚动起来。每次滚动2000次。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/06/20170805离线赛/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
</section>
    
    <nav class="pagination">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 ></a>
    </nav>


        </main>
        <footer class="footer syuanpi fadeIn" id="footer">
    <hr>
    <div class="footer-wrapper">
        <div class="left">
            <div class="contact-icon">
    
    
    
    
    
    
    
    
</div>
        </div>
        <div class="right">
            <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>1970 ~ 2017</span>
        <span>❤</span>
        <span>nanhan</span>
    </div>
    <div class="theme">
        <span>
            动力来源于
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            主题
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
    <div class="visit_count">
        <i class="iconfont icon-visit"></i>
        <span id="busuanzi_value_site_uv"></span>
        <i class="iconfont icon-people"></i>
        <span id="busuanzi_value_site_pv"></span>
    </div>
    
</div>
        </div>
    </div>
</footer>
    </div>
    <script src="/script/nlvi.js"></script>

    <script src="/lightbox/js/lightbox.min.js"></script>

<script>
$(document).ready(function(){
    document.body.addEventListener('touchstart', function () {});
    $('.progress').hide();
    $('.body').show();
    Nlvi.tagcloud();
    Nlvi.back2top();
    Nlvi.showToc();
    Nlvi.showComments();
    Nlvi.showReward()

    !CONFIG.animate && Nlvi.offAnimate();
    CONFIG.lightbox && Nlvi.onPicBox();
})
</script>
    </div>
    
    <div class="backtop syuanpi dead toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>
</body>
</html>
