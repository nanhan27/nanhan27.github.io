<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <title>
    nanhan27's Blog
    
</title>
    
<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<link rel="stylesheet" href="/style/style.css">
<script src="/script/jquery.min.js"></script>
<script>
    var CONFIG = {
        title: "nanhan27's Blog",
        author: "nanhan",
        lightbox: true,
        animate: true
    }
</script>



    <link rel="stylesheet" href="/lightbox/css/lightbox.min.css">




    <link rel="stylesheet" href="/syuanpi/syuanpi.min.css">









    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<!--Mathjax-->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
            processEscapes: true,
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
    }); 
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';                 
        }       
    });
    </script>
    <script type="text/javascript" async
        src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>
</head>
<body>
    <div class="progress">
    <div class="progress-inner"></div>
</div>
    <div class="body">
    <div class="tagcloud" id="tagcloud">
    <div class="tagcloud-inner">
        <a href="/tags/A-剪枝/" style="font-size: 14px;">A*剪枝</a> <a href="/tags/CDQ分治/" style="font-size: 14px;">CDQ分治</a> <a href="/tags/Tarjan/" style="font-size: 14px;">Tarjan</a> <a href="/tags/Trie树/" style="font-size: 14px;">Trie树</a> <a href="/tags/YY/" style="font-size: 14px;">YY</a> <a href="/tags/dfs序/" style="font-size: 14px;">dfs序</a> <a href="/tags/dp/" style="font-size: 14px;">dp</a> <a href="/tags/二分/" style="font-size: 14px;">二分</a> <a href="/tags/二分图/" style="font-size: 14px;">二分图</a> <a href="/tags/优先队列/" style="font-size: 14px;">优先队列</a> <a href="/tags/倍增/" style="font-size: 14px;">倍增</a> <a href="/tags/倍增LCA/" style="font-size: 14px;">倍增LCA</a> <a href="/tags/几何/" style="font-size: 14px;">几何</a> <a href="/tags/分块/" style="font-size: 14px;">分块</a> <a href="/tags/分治/" style="font-size: 14px;">分治</a> <a href="/tags/分组背包/" style="font-size: 14px;">分组背包</a> <a href="/tags/前缀和/" style="font-size: 14px;">前缀和</a> <a href="/tags/剪枝/" style="font-size: 14px;">剪枝</a> <a href="/tags/区间查询/" style="font-size: 14px;">区间查询</a> <a href="/tags/单调栈/" style="font-size: 14px;">单调栈</a> <a href="/tags/单调队列/" style="font-size: 14px;">单调队列</a> <a href="/tags/博弈/" style="font-size: 14px;">博弈</a> <a href="/tags/卢卡斯定理/" style="font-size: 14px;">卢卡斯定理</a> <a href="/tags/后缀数组/" style="font-size: 14px;">后缀数组</a> <a href="/tags/图论/" style="font-size: 14px;">图论</a> <a href="/tags/字符串/" style="font-size: 14px;">字符串</a> <a href="/tags/完美匹配/" style="font-size: 14px;">完美匹配</a> <a href="/tags/容斥/" style="font-size: 14px;">容斥</a> <a href="/tags/尺取/" style="font-size: 14px;">尺取</a> <a href="/tags/差分前缀和/" style="font-size: 14px;">差分前缀和</a> <a href="/tags/差分约束系统/" style="font-size: 14px;">差分约束系统</a> <a href="/tags/并查集/" style="font-size: 14px;">并查集</a> <a href="/tags/扫描线/" style="font-size: 14px;">扫描线</a> <a href="/tags/折半枚举/" style="font-size: 14px;">折半枚举</a> <a href="/tags/拓扑排序/" style="font-size: 14px;">拓扑排序</a> <a href="/tags/搜索/" style="font-size: 14px;">搜索</a> <a href="/tags/数位dp/" style="font-size: 14px;">数位dp</a> <a href="/tags/数学/" style="font-size: 14px;">数学</a> <a href="/tags/数论/" style="font-size: 14px;">数论</a> <a href="/tags/最小割/" style="font-size: 14px;">最小割</a>
    </div>
</div>
    <header class="header" id="header">
    <div class="title syuanpi tvIn">
    <div class="table">
        <div class="connect">
            <div class="connect-inner">
                <span><a href="/">nanhan27's Blog</a></span>
                
            </div>
        </div>
    </div>
</div>
    <nav class="main-nav syuanpi tvIn">
<div class="table">

    <ul class="menu">
        
        
            <li class="menu-item">
                <a href="/">
                    <span>文章</span>
                    
                        <span class="menu-item-label">article</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/archives">
                    <span>目录</span>
                    
                        <span class="menu-item-label">archives</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="javascript:;" id="tags">
                    <span>标签</span>
                    
                        <span class="menu-item-label">tags</span>
                    
                </a>
            </li>
        
        
        
            <li class="menu-item">
                <a href="/aboutme">
                    <span>关于</span>
                    
                        <span class="menu-item-label">about</span>
                    
                </a>
            </li>
        
        
    </ul>

</div>
</nav>
<div class="mobile-nav"></div>
</header>
    <div class="container">
        <main class="main" id="main">
            
    

<section class="posts">
    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月27日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/27/20170826离线赛 nanhan/">20170826离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、自动刷题机"><a href="#A、自动刷题机" class="headerlink" title="A、自动刷题机"></a>A、自动刷题机</h2><p>关键字：二分</p>
<p>【分析】</p>
<p>从感性的角度分析，一份代码需要的行数越大，份数越小；需要的行数越小，份数越大。所以答案是具有单调性的，那就可以二分了。</p>
<p>【反思】</p>
<p>一开始看到了不满足输出-1，但是写完代码的时候却忘了。看来写的时候应该将一些需要特别注意的地方用注释标出提醒自己。</p>
<h2 id="B、脑洞治疗仪"><a href="#B、脑洞治疗仪" class="headerlink" title="B、脑洞治疗仪"></a>B、脑洞治疗仪</h2><p>关键字：线段树</p>
<p>【分析】</p>
<p>看到题目的第一反应就是线段树。（<del>连暴力有多少分都没有看</del>）接下来就要看每个人的模拟能力了。</p>
<p>每个节点只要存区间的长度，0的个数，1的个数，这个区间最大连续的0的个数，从左端点起最长的连续0的个数和从右端点起最长的连续0的个数，以及操作的标记类型就行了。</p>
<p>由于这道题因为需要实现那些操作，用到的函数特别多，所以先别急着写，好好构思一下再写，代码就能精简很多，思路也会清晰很多。</p>
<h2 id="C、超能粒子炮"><a href="#C、超能粒子炮" class="headerlink" title="C、超能粒子炮"></a>C、超能粒子炮</h2><p>关键字：数学、卢卡斯定理</p>
<p>【分析】</p>
<p>这题的正解是Lucas定理在大组合数的取模的应用。</p>
<p>Lucas定理：</p>
<h5 id="A、B是非负整数，p是质数。AB写成p进制：A-a-n-a-n-1-…a-0-，B-b-n-b-n-1-…b-0-。"><a href="#A、B是非负整数，p是质数。AB写成p进制：A-a-n-a-n-1-…a-0-，B-b-n-b-n-1-…b-0-。" class="headerlink" title="A、B是非负整数，p是质数。AB写成p进制：A=a[n]a[n-1]…a[0]，B=b[n]b[n-1]…b[0]。"></a>A、B是非负整数，p是质数。AB写成p进制：A=a[n]a[n-1]…a[0]，B=b[n]b[n-1]…b[0]。</h5><h5 id="则组合数C-A-B-与C-a-n-b-n-C-a-n-1-b-n-1-…-C-a-0-b-0-p同余"><a href="#则组合数C-A-B-与C-a-n-b-n-C-a-n-1-b-n-1-…-C-a-0-b-0-p同余" class="headerlink" title="则组合数C(A,B)与C(a[n],b[n])C(a[n-1],b[n-1])…*C(a[0],b[0])  % p同余"></a>则组合数C(A,B)与C(a[n],b[n])<em>C(a[n-1],b[n-1])</em>…*C(a[0],b[0])  % p同余</h5><h5 id="即：Lucas-n-m-p-C-n-p-m-p-Lucas-n-p-m-p-p"><a href="#即：Lucas-n-m-p-C-n-p-m-p-Lucas-n-p-m-p-p" class="headerlink" title="即：Lucas(n,m,p)=C(n%p,m%p)*Lucas(n/p,m/p,p)"></a>即：Lucas(n,m,p)=C(n%p,m%p)*Lucas(n/p,m/p,p)</h5><p>如果知道了这个定理，那么50分就能拿到了。</p>
<p>100分就是定义$S[i][j]=\sum _{k=0}^{j}C\left[ i\right] \left[ k\right]$，因为$K=k1*p+k2$，所以分开计算，并且将式子转化到可以递归求解就好了。（<del>推了我好久</del>）</p>
<p>【反思】</p>
<p>赛场上想用$O(n)$求出逆元算出组合数，结果逆推逆元的公式花了一会儿推出来，敲完之后调了半个小时，发现是快速幂敲错了……最后发现因为这个p=2333太小了，逆元计算时会出错，必须要考虑n！、m！和（n-m）！中2333的个数。因为时间问题，我去敲了一个暴力求组合数，结果第二层循环变量j&lt;=i&amp;&amp;j&lt;=K写成了j&lt;=i&amp;&amp;i&lt;=K……错误百出！</p>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月25日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/25/20170825离线赛/">20170825离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、金子——-CCPC"><a href="#A、金子——-CCPC" class="headerlink" title="A、金子——$CCPC$"></a>A、金子——$CCPC$</h2><p>关键字：$dp$</p>
<p>【分析】</p>
<p>做过，不过看了下这次的做法和上次的做法不一样，而且觉得这次的四维$dp$比上次的状态思路更加清晰和直接，还是挺开心的。</p>
<p>定义$dp[cur][i][j][k]$表示此时用了i的长度，左边是否被用了，右边是否被用了。这样转移很容易。</p>
<p>而且让总长度和需要的长度都乘2，就能解决一些奇怪的情况了。</p>
<h2 id="B、货物运输"><a href="#B、货物运输" class="headerlink" title="B、货物运输"></a>B、货物运输</h2><p>关键字：并查集</p>
<p>【分析】</p>
<p>这道题可能是最近那么多模拟赛B题中最水的一道了……</p>
<p>开始看错题目，看不懂题目中的加油是个什么意思。等我写完最短路暴力发现过不了最后一个样例的时候才发现好像看错题目了……</p>
<p>对于一个油箱容量C，只有距离小于等于C的边能加入到图中。那么我们先按照容量从小到大排序，对于一个新的容量，原来已添加的边不会改变，而能添加更多的边。所以我们可以先将边按距离从小到大排序。那么每次加边就只需要将边两端的集合并在一起，再重新计算答案，这个可以用并查集完成。</p>
<h2 id="C、数组游戏"><a href="#C、数组游戏" class="headerlink" title="C、数组游戏"></a>C、数组游戏</h2><p>关键字：博弈</p>
<p>【分析】</p>
<p>首先因为Yes和No打错了，暴力就$GG$了……</p>
<p>当然是道博弈题，但关键是每个状态的子问题是什么。</p>
<p>若此时有一个黑棋，如果有个人翻了这个黑棋是必胜策略，那么下一个人也能再翻这个棋子。因此，如果考虑最优的情况，是没有一方会去翻黑棋。那么题目就转化成：<strong>存在若干白点，然后将所有点翻转成黑点，先全部翻转的为胜。</strong></p>
<p>那么我们将每个点看成一个子问题，把所有点的$SG$异或起来就好了。</p>
<p>可以得到：</p>
<p>$SG(i)=mex(SG[i<em>1] ⊕ SG[i</em>2]⊕…⊕SG[i*k])(k \in [2,N/i])$</p>
<p>有了这条式子，70分就到手了。</p>
<p>因为n的范围太大了， 我们考虑将n进行分块。</p>
<p>然后有一个结论：若$\lfloor\frac{n}{i}\rfloor=\lfloor\frac{n}{j}\rfloor$,则$SG[i]=SG[j]$，所以$SG$函数的取值只有$\sqrt n$种，然后就可以将$SG$值相同的情况合并在一起，数组就开的下了。</p>
<p>【反思】</p>
<p>不看清题目，把Yes和No都看错，就算写出正解也没用。</p>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月23日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/23/20170821离线赛/">20170821离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、猴子拆房"><a href="#A、猴子拆房" class="headerlink" title="A、猴子拆房"></a>A、猴子拆房</h2><p>关键字：终态枚举</p>
<p>【分析】</p>
<p>枚举一个最后的最高高度h，那么大于h的一定要拆掉，小于h的个数数也要比等于h的个数少。我们先让高度有序，预处理出若h为最高高度，需要拆掉大于h的花费，然后从低到高枚举，每次在一棵权值线段树查询前k小的花费的总和，然后把这个点也更新到线段树上就好了。</p>
<p>关键的是，花费的范围很小，只有500，建线段树实在是比较傻，直接计数就好了。（<del>虽然跑得比线段树慢得多</del>）</p>
<p>【反思】</p>
<p>敲代码的时候应该多注意一下一些特殊的数据范围，像这题的花费范围很小，如果没有注意到，不仅要写线段树浪费时间，调试的时间肯定会比计数排序的要多。</p>
<h2 id="B、消防——-SDOI2011"><a href="#B、消防——-SDOI2011" class="headerlink" title="B、消防——$SDOI2011$"></a>B、消防——$SDOI2011$</h2><p>关键字：树的直径、二分、尺取</p>
<p>【分析】</p>
<p>先说一下小分怎么切。</p>
<p>第一档直接暴力就行了。</p>
<p>第二档的$O(n^2\log n)$还是比较好想的，关键是被卡了……二分一个答案，枚举一个起点，以它作为根建树。因为我们要的是一条路径，使得，每个点到达路径上的点的最大距离小于等于$lim$，所以算出它的花费，再和给定的S进行比较。</p>
<p>第二档还有个$O(n^2)$的做法，枚举起点作为根，用树形$dp$算出每个点子树中最大的距离的儿子、次大的。然后再一次$dfs$就能直接计算这种情况下的答案了，最后都更新一遍答案就好了。</p>
<p>至于正解，就是树的直径+尺取+$multiset$。但是因为比赛的时候时间分配的问题，敲完这题第二档，然后去敲<del>SB</del>的第三题的暴力，写了很久，导致我没有时间去写这个一开始就想到的正解了……</p>
<p>我们发现最后的那条路径的起点和终点一定会在直径上，所以对于一条路径，维护起点之前的最大距离，终点之后的最大距离，以及这条路径上的最大距离。</p>
<p>【反思】</p>
<p>比赛时间的分配是一个大问题。</p>
<h2 id="C、游戏——-SDOI2016"><a href="#C、游戏——-SDOI2016" class="headerlink" title="C、游戏——$SDOI2016$"></a>C、游戏——$SDOI2016$</h2><p>关键字：李超线段树</p>
<p>【分析】</p>
<p>先树剖，将树转化成链。讲题目中的dis进行一些变形和转化，就能得到新的a和b，题目就转化成求一个区间中若干条直线y=a*x+b的最小值了。</p>
<p>然后用一个名叫超哥线段树的东西解决。只要知道在这棵奇怪的树上存的东西的意义是什么就好了：在一个区间中，a和b代表的这条直线对于至少一半的区间中的x，在所有直线中的y是最小值。</p>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月22日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/22/20170820离线赛/">20170820离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、打地鼠——-SDOI-2011"><a href="#A、打地鼠——-SDOI-2011" class="headerlink" title="A、打地鼠——$SDOI$2011"></a>A、打地鼠——$SDOI$2011</h2><p>关键字：差分前缀和、剪枝</p>
<p>【分析】</p>
<p>这道题暴力$O(n^6)$+可行性剪枝+最优性剪枝在没有那种特别的卡人数据的情况下是可以过的（关键是这种数据很难造）。</p>
<p><strong>剪枝</strong>：</p>
<p>可行性剪枝：若锤子的规格为$r<em>c$，因为题目要求每次一定会锤去$r</em>c$值地鼠，所以锤的次数为$sum/(r*c)$，且要求需要整除。那么也需要满足$sum \% r=0$，$sum \% c=0$了。</p>
<p>最优性剪枝：在满足可行的情况下，如果$sum/(r<em>c) \ge ans$（当前已求出），那么无论是否能够实现，这个$r</em>c$已经对答案没有意义了，我们也就不用$O(n^4)$在去判断了。</p>
<p>讲一下用$O(n^4)$判断。因为我们不知道该按照怎样的顺序开始锤，所以我们从边界开始考虑。对于（1,1）这个点，被锤的方式只有一种。当（1,1）被锤后，（1,2）这个点被锤的方式也是唯一的。所以for过来就好了。</p>
<p>接下来讲一下正解：</p>
<p>这题就是之前写过的一维的刷漆的升级。</p>
<p>对于r和c，处理一个点（i，j），需要将一个矩阵都减少这个点的地鼠个数v。那么只需要将点（i+r，j）加上v，点（i，j+c）加上v，（i+r,j+c）减去v就好了。这样就可以$O(n^2)$判断是否可行了。最后的复杂度是$O(n^4)$，当然实际复杂度要远小于它，因为有上面两个很强的剪枝，尤其是那个可行性剪枝。</p>
<p>【反思】</p>
<p>比赛的时候直接敲了$O(n^6)$+剪枝，而且自己出了个大数据，发现快的飞起，就能感觉出那两个剪枝很强，就放心的写后面的题目了。现在想想，做得很对。</p>
<p>【总结】</p>
<p>1、可行性剪枝和最优性剪枝在搜索题中应用很广，但是需要注意那些预估函数自身的复杂度是否能够代替被减去搜索部分，不然得不偿失。</p>
<p>2、二维差分前缀和这个工具虽然并不是太常见，但还是能够从已有的知识迁移过来的，需要一点想法。</p>
<h2 id="B、乐乐的栈游戏——-COCI-2014-2015-Contest-3-E"><a href="#B、乐乐的栈游戏——-COCI-2014-2015-Contest-3-E" class="headerlink" title="B、乐乐的栈游戏——$COCI$2014/2015 Contest#3 E"></a>B、乐乐的栈游戏——$COCI$2014/2015 Contest#3 E</h2><p>【分析】</p>
<p>比赛的时候完全没有思路，因为单纯地在“栈”这个基础上思考，完全没有将这个“栈”往树上思考。</p>
<p>因为考试常规的思路就那么几个，之前肯定做过类似的题目。如果往树上一想，就会发现1操作和在树上新建一个节点的过程十分类似，2操作也是一样。那么这道题就是一道模拟题了，就没有了。</p>
<p>【反思】</p>
<p>题目虽然会比较奇怪，但是思路是我们熟悉的思路。之前有一道<strong>函数返回值</strong>的题目，题目本身也是比较奇怪的，但你如果发现相互的约束条件是树形的结构，那么这道题就做出来一半了。</p>
<p>【总结】</p>
<p>看到奇怪的题目没有思路，多去往熟悉的模型上思考，把相似的知识点都活跃起来。</p>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月20日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/20/差分约束系统/">差分约束系统</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <p>首先这个东西能够解决类似下面的问题（每两个未知数中用减号连接，且要是整数解）：</p>
<p>若：</p>
<p>$x1-x2 \leq 5$</p>
<p>$x2-x3\geq10$</p>
<p>$x4-x3 \leq 10$</p>
<p>问$x1$与$x4$的最大（小）差是多少。</p>
<p>注意到求解的过程和求最短路的过程本质上是一样的，我们可以用Bellman_Ford或$SPFA$。</p>
<p>如果保证有解（即不会产生负环），那么可以用最短路的其他方法求解。</p>
<p>关键是怎么建边。</p>
<p>我设计的套路就是先将不等号统一方向，然后<strong>减数</strong>指向<strong>被减数</strong>，边权是不等号右边的值。</p>
<p>还有一个需要注意的，如何判断到底要跑最短路还是最长路。这个不能死记硬背，因为时间一长会忘的，只需要记住判断的方法。</p>
<p>像$x1-x2 \leq 5$，首先是2指向1，边权为5。将不等式化简得到$x1 \leq x2+5$就能知道$x1$的距离会比$x2$的距离加上这条边的权值小，所以要跑最短路。</p>
<p>如果$x1-x2 \geq 5$，也按照这样分析，能够得出要跑最大路。</p>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月19日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/19/20170819离线赛/">20170814离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、LOVE"><a href="#A、LOVE" class="headerlink" title="A、LOVE"></a>A、LOVE</h2><p>关键字：前缀和、高精</p>
<p>Task</p>
<p>在一个字符串中，按照顺序选出四个字母，组成LOVE，有多少种方案。</p>
<p>【分析】</p>
<p>这道题比较正常，写法还是比较多样的。</p>
<p>那么用前缀的想法，可以算出当前的O以及之前的O组成LO的方案，当前的V以及之前组成$LOV​$的方案，对于一个E，就能计算出LOVE的方案了。</p>
<p>但是我在比赛的时候知道100%的数据会爆long long，为了省麻烦，就将long long换成了double！完全没有考虑double的有效位数只有16位。</p>
<p>【反思】</p>
<p>考试就是那更多的分数，不要怕麻烦。</p>
<p>【总结】</p>
<p>double的有效精度只有16位！</p>
<p>double的有效精度只有16位！</p>
<p>double的有效精度只有16位！</p>
<h2 id="B、毕加猪"><a href="#B、毕加猪" class="headerlink" title="B、毕加猪"></a>B、毕加猪</h2><p>关键字：图论、有负权的最短路</p>
<p>Task</p>
<p>在有向图中，是否存在一条路径，使得从起点到终点的权值和小于等于T。</p>
<p>【分析】</p>
<p>比较容易想到需要找到负环。只要起点能到达某个负环，并且这个负环能到达终点，那么就能按时到达。但是当时脑子一片空白，完全不会。</p>
<p>之前当然是知道有些最短路的算法能够处理边权有负的情况，但是真的很少用$Bellmen\ Ford$、$SPFA$去处理，甚至连用$Floyd$判断是否存在负环都很模糊。</p>
<p>比赛的时候就稀里糊涂地用$tarjan$先缩了个点，然后在每个强连通中判断每个强连通中有没有负环。如果没有负环就直接$Floyd$，如果有的话，再重新建边，将连向负环的边权设为负无穷，然后$Floyd$。</p>
<p>然而正解只需要用$Floyd$找出某一个点是否在负环上，且这个点与起点和终点是联通的就行了。</p>
<p>【反思】</p>
<p>1、对经典的算法不重视，以为只要掌握$Dijkstra$和$Floyd$就够用了。</p>
<p>2、只需要判断是否存在某个负环，与起点和终点相连通，而我却在知道有没有负环后重新建图，对我所求得目标不明确，思路不清晰。</p>
<p>【总结】</p>
<p>$Floyd$判断是否存在负环只需要判断$dis[i][i]$是否小于0。</p>
<p>$SPFA$判断是否存在负环只需要一个点进入队列的次数是否大于$n-1$。</p>
<p>$Bellmen\ Ford$与$SPFA$类似，判断在在更新$n-1$次后判断每条边是否还能让路径两端的点的距离继续减小。</p>
<p>【代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> debug(x) cout&lt;&lt;#x&lt;&lt;<span class="meta-string">" = "</span>&lt;&lt;x&lt;&lt;endl;</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> oo 1e18</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> M 3005</span></div><div class="line"><span class="keyword">int</span> n,m,ti,cas;</div><div class="line">ll d[M][M];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;cas);</div><div class="line">    <span class="keyword">while</span>(cas--)&#123;</div><div class="line">        <span class="keyword">int</span> p,q;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;n,&amp;m,&amp;ti);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)d[i][k]=oo;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,u,v,c;i&lt;=m;i++)&#123;</div><div class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>,&amp;u,&amp;v,&amp;c);</div><div class="line">            d[u][v]=min(d[u][v],<span class="number">1l</span>l*c);</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;p,&amp;q);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</div><div class="line">                    d[j][k]=min(d[j][k],d[j][i]+d[i][k]);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span>(d[p][q]+ti&lt;=<span class="number">0</span>||d[q][p]+ti&lt;=<span class="number">0</span>)<span class="built_in">puts</span>(<span class="string">"yes"</span>);</div><div class="line">        <span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">bool</span> ok=<span class="number">1</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n&amp;&amp;ok;i++)&#123;</div><div class="line">                <span class="keyword">if</span>(d[i][i]&lt;<span class="number">0</span>)&#123;</div><div class="line">                    <span class="keyword">if</span>(d[p][i]!=oo&amp;&amp;d[i][q]!=oo||d[q][i]!=oo&amp;&amp;d[i][p]!=oo)ok=<span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(ok)<span class="built_in">puts</span>(<span class="string">"no"</span>);</div><div class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"yes"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="C、k倍数字——-UOJ140"><a href="#C、k倍数字——-UOJ140" class="headerlink" title="C、k倍数字——$UOJ140$"></a>C、k倍数字——$UOJ140$</h2><p>关键字：数位$dp$</p>
<p>Task</p>
<p>给定两个数字R和k，求满足下列条件的x个数。</p>
<p>1、满足1≤x≤R</p>
<p>2、定义函数f(x) 为 x 的各位数字之和，例如f(13)=4,f(233)=8。满足 f(x)=f(k·x)</p>
<p>【分析】</p>
<p>数位$dp$应该很好想到，关键是哪些状态需要存在下标上才能进行转移。</p>
<p>通常的数位$dp$应该是从高位往低位的，但是因为这道题目如果从高位往低，那么转移就比较麻烦，所以选择从低往高。对于每一位，我们要添加一个数字，那么此时的各位数字之和是能够转移过来的。但是这些信息并不能直接算出$k·x$的各位数字之和。</p>
<p>我在网上大概搜了一下，$dp$下标存的大概有这些东西：数位和、数位和模后的结果、是否进位、进位所少、前一位是多少、是否已经满足了约束条件、有无前导零和是否严格小于上限等等。经验要慢慢积累，但是知道这些起码有一些方向可以去尝试。</p>
<p>至于这道题，我们记录当前这个数的数位和、这个数$<em>K$后的数位和，这个数$</em>K$后的数位和所产生的进位是多少。</p>
<p>那么就可以转移了：</p>
<p>$dp[i+1][sum+ch][sum1+(ch<em>K+r)10][(ch</em>K+r)/10]=dp[i][sum][sum1][r]$</p>
<p>由于还要考虑当前数字是否严格小于上限R，所以还需要一维p记录状态。</p>
<p>但是这样空间会炸，所以我们不能将两个sum同时记录下来了，我们将两个sum的差d记录在$dp$上。</p>
<p>【反思】</p>
<p>暴力炸了就真的没有救了。</p>
<p>【总结】</p>
<p>数位$dp$的下标存的状态与前面已经枚举的数位有关并且通常是根据约束条件当前枚举的这一位能使得状态<strong>完整</strong>(比如一个状态涉及到连续k位，那么就保存前k-1的状态，当前枚举的第k个是个恰好凑成成一个完整的状态，不过像状态是数位的和就直接保存前缀和为状态了)</p>
<p>【代码】</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</div><div class="line">ll dp[<span class="number">25</span>][<span class="number">410</span>][<span class="number">1010</span>][<span class="number">2</span>];</div><div class="line"><span class="keyword">char</span> s[<span class="number">25</span>];</div><div class="line"><span class="keyword">int</span> K,n;</div><div class="line">ll R;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld %d"</span>,&amp;R,&amp;K);</div><div class="line">    <span class="keyword">while</span>(R)s[++n]=R%<span class="number">10</span>,R/=<span class="number">10</span>;</div><div class="line">    dp[<span class="number">0</span>][<span class="number">200</span>][<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+<span class="number">2</span>;i++)&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> d=<span class="number">0</span>;d&lt;=<span class="number">400</span>;d++)&#123;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)&#123;</div><div class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> now=<span class="number">0</span>;now&lt;<span class="number">2</span>;now++)&#123;</div><div class="line">                    <span class="keyword">if</span>(!dp[i][d][j][now])<span class="keyword">continue</span>;</div><div class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> ch=<span class="number">0</span>;ch&lt;<span class="number">10</span>;ch++)&#123;</div><div class="line">                        <span class="keyword">int</span> nxt;</div><div class="line">                        <span class="keyword">if</span>(s[i+<span class="number">1</span>]&gt;ch)nxt=<span class="number">0</span>;</div><div class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(s[i+<span class="number">1</span>]&lt;ch)nxt=<span class="number">1</span>;</div><div class="line">                        <span class="keyword">else</span> nxt=now;</div><div class="line">                        <span class="keyword">int</span> nj=(K*ch+j)/<span class="number">10</span>;</div><div class="line">                        <span class="keyword">int</span> nd=d+ch-(K*ch+j)%<span class="number">10</span>;</div><div class="line">                        dp[i+<span class="number">1</span>][nd][nj][nxt]+=dp[i][d][j][now];</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>,dp[n+<span class="number">3</span>][<span class="number">200</span>][<span class="number">0</span>][<span class="number">0</span>]<span class="number">-1</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月18日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/18/数位dp模板/">数位dp模板</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <p>由于百度之星复赛那道数位$dp​$的爆炸，我发现我写数位$dp​$的记搜版本并没有什么套路，重新写一道题就要重新去考虑哪些细节该怎样设计，这样会花费我大量的时间，所以我在这里放一份较为通用的模板，供自己参考。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/18/数位dp模板/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月17日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/17/2017 Multi-University Training Contest 7/">2017 Multi-University Training Contest 7</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="1006、Free-from-square"><a href="#1006、Free-from-square" class="headerlink" title="1006、Free from square"></a>1006、Free from square</h2><p>关键字：状压$dp$、分组背包</p>
<p>【分析】</p>
<p>题目的模型稍微转化一下，就是说选一些互质的数。因为一个数不会含有两个大于$\sqrt {n}$的质因数，所以我们开始思考小于$\sqrt {n}$的质因数。这样的质因数只有8个，所以想到状压，将取的集合存在下标。</p>
<p>但是大于$\sqrt {n}$的质因数该怎么处理？由于大于$\sqrt {n}$的质因数的个数很多，不可能把它存在下标上，所以我们需要一种$dp$转移的顺序，使得最后计算的答案既不重复也不遗漏。比赛的时候就是卡在了这里！我只是想到43、86之类的不能放在一起，$YY$了一下莫比乌斯系数，发现太过复杂，也就没有继续往下想了。</p>
<p>实际上，这就是分组背包嘛！那么这道题也就没有了。</p>
<p>$dp[cur][j][s]$表示当前组cur，取j个数，小于$\sqrt {n}$的质因数的集合为s。</p>
<p>而且还有一个小优化：实际上对于n=500，最多能取到的数也只有95个。所以$dp$的空间能节省很多，速度也就变快了。</p>
<p>【算法流程】</p>
<p>1、将含有大于$\sqrt {n}$的质因数的数先处理。</p>
<p>2、处理只含小于$\sqrt {n}$的质因数并且本身不含有平方因子的数。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/17/2017 Multi-University Training Contest 7/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月16日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/16/20170814离线赛/">20170814离线赛</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="A、完全图计数"><a href="#A、完全图计数" class="headerlink" title="A、完全图计数"></a>A、完全图计数</h2><p>关键字：折半枚举，高维前缀和</p>
<p>【分析】</p>
<p>比赛的时候爆0真的是没想到。</p>
<p>一开始当然想到了$O(n<em>2^n)$的暴力，这样就能拿到70分了。但是我却写了一个奇怪的写法，希望能水到更多分。样例也跑出来了。谁知道在$dfs$里面会忘了$return$。就爆0了。这还不止，我加了$return$后交到网站去，结果只有60分。连$O(n</em>2^n)$的暴力都不如……看来比赛的时候还是应该稳，把该拿到的分全部拿到再说别的。</p>
<p>正解是折半枚举。折半枚举的特征大概就是在$O(2^n)$不能解决的时候$O(2^{n/2})$却能解决。想法是枚举一半，计算另一半。</p>
<p>我们将$[0,n/2-1]$取或不取的集合的情况处理出来，然后用高维前缀和处理出任意集合包含其子集的可行的方案数。大概是这样的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;hf;i++)&#123;</div><div class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=(<span class="number">1</span>&lt;&lt;hf)<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--)&#123;</div><div class="line">		<span class="keyword">if</span>(j&amp;(<span class="number">1l</span>l&lt;&lt;i))cnt[j]+=cnt[j^(<span class="number">1</span>&lt;&lt;i)];</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么对于$[n/2,n-1]$$dfs$枚举集合时，直接用已处理出的$[0,n/2-1]$的方案计算即可。</p>
<p>【总结】</p>
<p>1、多分析数据。</p>
<p>2、暴力别敲错！</p>
<h2 id="B、书架面积——NWERC-2006"><a href="#B、书架面积——NWERC-2006" class="headerlink" title="B、书架面积——NWERC 2006"></a>B、书架面积——NWERC 2006</h2><p>关键字：$dp$</p>
<p>【分析】</p>
<p>这道题花了我将近三个小时。这其实是一个重大的失误。</p>
<p>前一个小时敲一个我认为能拿70分（$O(150^3*n)$）的贪心，所以没有敲其他的切分代码（实在不应该）。先按宽度排序，枚举三行的最高长度，然后贪心先放此时宽度最大的，并且时刻维护三行的最高长度不变。</p>
<p>但是大数据过不了，大了十几。接下来半个小时开始调试，没有看出代码的问题。可能是算法的问题！由于需要满足放在某一行的书的高度不能超过枚举的高度，会导致贪心出错！</p>
<p>鉴于仅剩一个半小时，第三题还没有写，我去看第三题，并花了20分钟将暴力敲完，综合当时的情况，我便没有去敲“没有2操作”的切分，继续回到了第二题来。</p>
<p>我舍弃一开始枚举三行的最高长度的贪心思路，转向用宽度$dp$。若将宽度存入下标，只需要将两行的宽度，最后一行是可以直接算出来的。$dp[a][i][j]$的定义为取到第a个，第一行的宽度为i，第二行的宽度为j的最小的最大高度和。开始$dp$转移之前先将书按照高度排序，这样就能保证取第a个在第一行（或第二行）的时候不会让原有的最高高度发生改变，使$dp$的转移的信息一定是正确的。</p>
<p>当然这时$dp$数组是开不下的。我们从$dp$转移入手：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(dp[i<span class="number">-1</span>][j][k]==<span class="number">-1</span>)<span class="keyword">continue</span>;</div><div class="line"><span class="keyword">if</span>(k==<span class="number">0</span>)chk(dp[i][j][k+a[i].t],dp[i<span class="number">-1</span>][j][k]+a[i].h);</div><div class="line"><span class="keyword">else</span> chk(dp[i][j][k+a[i].t],dp[i<span class="number">-1</span>][j][k]);</div><div class="line"><span class="keyword">if</span>(j==<span class="number">0</span>)chk(dp[i][j+a[i].t][k],dp[i<span class="number">-1</span>][j][k]+a[i].h);</div><div class="line"><span class="keyword">else</span> chk(dp[i][j+a[i].t][k],dp[i<span class="number">-1</span>][j][k]);</div><div class="line"><span class="keyword">if</span>(sum-j-k==<span class="number">0</span>)dp[i][j][k]+=a[i].h;</div></pre></td></tr></table></figure>
<p>我们发现当前第i个的信息完全是由i-1那里继承过来的。（因为书一定要放在书架上），所以直接将第一维省去就好了。</p>
<p>【总结】</p>
<p>1、不管有没有想到正解，暴力和切分一定要敲。</p>
<h2 id="C、奇怪的树"><a href="#C、奇怪的树" class="headerlink" title="C、奇怪的树"></a>C、奇怪的树</h2><p>关键字：树状数组、树链剖分</p>
<p>【分析】</p>
<p>1~2：暴力20分</p>
<p>5、7 、8：30分</p>
<p>我们先考虑一下1、2操作本质会产生什么影响。</p>
<p>1操作的实质就是如果这个点的$dep$是奇数，那么$dep$为偶数的点的颜色会改变。同理$dep$是偶数，那么$dep$为奇数的点的颜色会改变。</p>
<p>如果没有操作2的话，那么这一棵树其实只有四种情况：</p>
<p>1、都不改</p>
<p>2、奇数点不改，偶数点改</p>
<p>3、奇数点改，偶数点不改</p>
<p>4、都改</p>
<p>那么对于没有2操作时，我们能够用四次$dfs$预处理出所有的答案。这里有。</p>
<p>3：10分</p>
<p>在链上，我们考虑一个点i的答案是怎么组成的。应该是这个点左边黑点的$dfn$之和、右边黑点的个数乘i相加得到。那我们还是维护四种情况的这两个信息就好了。因为这是单点更新（2操作），区间查询，所以我们可以用线段树或树状数组来维护。</p>
<p>至于正解，用树链剖分将树转化成若干链，然后更新和询问都是跳重链。思路和链的想法差不多，只不过在计算答案的时候注意将重复计算的部分减掉！</p>
<p>【总结】</p>
<p>1、从小分的写法深入</p>
<p>2、自己不太好写，别人也不一定能写，不要钻牛角尖</p>

                
            
        
        </div>
        
    </article>
    

    
        
    <article class="post">
        <header class="post-header">
            <div class="post-time syuanpi riseIn-light back-1">
                <span>2017年8月13日</span>
            </div>
            <h1 class="post-title syuanpi riseIn-light back-2">
            
                <a href="/2017/08/13/2017 Multi-University Training Contest 6/">2017 Multi-University Training Contest 6</a>
            
            </h1>
            
        </header>
        <div class="post-content syuanpi riseIn-light back-3">
            
                
                    <h2 id="1001、String"><a href="#1001、String" class="headerlink" title="1001、String"></a>1001、String</h2><p>关键字：字符串、$Trie$树、$CDQ$分治</p>
<p>【分析】</p>
<p>首先我们可以知道，如果将单词按字典序排序，那么对于一个前缀，单词所在的下标一定是一段连续的区间。将单词旋转后排序，查询后缀也是一样的。</p>
<p>那么题目就转化成对于一个询问，其正序下标在$[x1,x2]$，逆序下标在$[y1,y2]$的单词有多少个。</p>
<p>如果知道了一个询问的$x1、x2、y1、y2$，那么题目就等价于求平面上一个矩形中的点的个数，这个可以用扫描线+线段树完成。</p>
<p>预处理出$x1、x2、y1、y2$可以用$Trie$树来完成，即每个节点存下某个前缀的字典序下标的最大和最小值。然后用询问的前缀和后缀去跑这棵$Trie$树。</p>
<p>但是题目中还有一个限制条件：$前缀和后缀不能重叠。$</p>
<p>这个条件正解中是用$Hash$将不满足的情况减去，但是$小C$说这样太麻烦了。这样就说明一个单词，如果其长度小于询问的前缀+后缀长度，那么它是不能被计算的，所以我们人为地添加了操作顺序这一维度，即边加点边询问。而这个问题正是$CDQ$的入门题目$Mokia$。</p>
<p>【算法流程】</p>
<p>1、顺序字符串排序，建$Trie$树，更新节点的信息。询问的前缀查询区间$[x1,x2]$。</p>
<p>2、逆序字符串做相同操作。</p>
<p>3、将插入和询问操作按长度从大到小排序，进行$CDQ$分治，BIT维护。</p>
                    
            
        
            <p class="content-link">
                <a href="/2017/08/13/2017 Multi-University Training Contest 6/#more">
                    <span class="iconfont icon-right">继续阅读</span>
                </a>
            </p>
        
        </div>
        
    </article>
    

    
</section>
    
    <nav class="pagination">
        <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">下一页 ></a>
    </nav>


        </main>
        <footer class="footer syuanpi fadeIn" id="footer">
    <hr>
    <div class="footer-wrapper">
        <div class="left">
            <div class="contact-icon">
    
    
    
    
    
    
    
    
</div>
        </div>
        <div class="right">
            <div class="copyright">
    <div class="info">
        <span>&copy;</span>
        <span>1970 ~ 2017</span>
        <span>❤</span>
        <span>nanhan</span>
    </div>
    <div class="theme">
        <span>
            动力来源于
            <a href="http://hexo.io/" target="_blank">Hexo </a>
        </span>
        <span>
            主题
            <a href="https://github.com/ColMugX/hexo-theme-Nlvi"> Nlvi </a>
        </span>
    </div>
    
    <div class="visit_count">
        <i class="iconfont icon-visit"></i>
        <span id="busuanzi_value_site_uv"></span>
        <i class="iconfont icon-people"></i>
        <span id="busuanzi_value_site_pv"></span>
    </div>
    
</div>
        </div>
    </div>
</footer>
    </div>
    <script src="/script/nlvi.js"></script>

    <script src="/lightbox/js/lightbox.min.js"></script>

<script>
$(document).ready(function(){
    document.body.addEventListener('touchstart', function () {});
    $('.progress').hide();
    $('.body').show();
    Nlvi.tagcloud();
    Nlvi.back2top();
    Nlvi.showToc();
    Nlvi.showComments();
    Nlvi.showReward()

    !CONFIG.animate && Nlvi.offAnimate();
    CONFIG.lightbox && Nlvi.onPicBox();
})
</script>
    </div>
    
    <div class="backtop syuanpi dead toTop" id="backtop">
    <i class="iconfont icon-up"></i>
    <span style="text-align:center;font-family:Georgia;"><span style="font-family:Georgia;" id="scrollpercent">1</span>%</span>
</div>
</body>
</html>
